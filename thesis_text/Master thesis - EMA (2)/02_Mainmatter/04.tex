\chapter{Overview of available tools}
\label{chap:four}
Many solutions have been made to ease the exploration, analysis, and visualization of data. The solutions can be either paid (Tableau, FIND EXAMPLES) or available as freeware (Google Charts). However, these solutions often are not suitable for bioinformatical purposes. 

There are many options for programming languages that can be used for data visualization (R, Scala, Matlab, Python, Java, C\#, and others). Python and R are especially popular in bioinformatics and biology \citep{giorgi2022r, gentleman2008r, bassi2016python}. There are many advantages to using Python. The user base is rather large - its userbase was the 5th largest on StackOverflow \citep{srinath2017python}. Its learning curve is flatter compared to other languages. Python also has the ability to follow multiple programming paradigms (object-oriented, imperative, functional, and for more experienced users even procedural) \citep{srinath2017python, dyer2022exploratory}. Python is dynamically typed, making prototyping easier at the cost of performance \citep{tratt2009dynamically}. There is also an abundance of free-to-use libraries.

As stated in \ref{sec:dataviz}, the ability to visualize the input and output of one's work is crucial to communicate patterns and information across in a clear and intuitive way. Choosing the right tool for the job is crucial. 

In this thesis, several mostly Python frameworks for building both front-end apps and graphing solutions are tested and compared. Keep in mind that the user should not look for one "best" solution and rather analyze their needs and expectations and choose a tool accordingly. 

\section{R Shiny (ShinyDendro)}
\label{sec:streamlit}
R Shiny is the only non-Pythonic open-source package that is discussed in the thesis. It is used for building web applications aimed at data scientists, as the tool is used for data exploration, analysis, and visualization. The finished application can be run either locally or deployed to a server, making it accessible to users all over the world. No knowledge of web development stack - HTML, CSS, JavaScript - is necessary. The R side of things is responsible for the data processing and analysis, while the rest of the stack handles user interface and interactions. A variety of premade tools is available, such as buttons, sliders, or menus. Premade layouts are also available, speeding up the process to a well-rounded looking application.

In 2022, PyShiny was announced, bringing Shiny to the Python ecosystem.

\section{Streamlit}
\label{sec:streamlit}
Streamlit is an open-source solution designed to make the creation of web apps as accessible to Python users as possible. The framework was created with machine learning and data science in mind. 
 
Streamlit does not require any knowledge of other languages that are usually used for web apps (Javascript, CSS, HTML, and others), and one of the huge advantages is that it removes the necessity of data transmission between Python and a non-Pythonic front-end. However, knowing HTML and JavaScript allows the user to develop their own Streamlit Components. The goal of Streamlit is to bridge the distance between Python and React, one of available JavaScript libraries, which is often used for creating interactive frontend interfaces, effectively wrapping React components. It is supported by Windows, Mac, and Linux operating systems, and by December 2022, it has over 21K stars on GitHub. It has demo apps published on GitHub to get one started. As per usual with Pythonic packages, installation is easy via a pip command, and prototyping can start fast. It brings its own syntax, but the learning curve is not too steep. 

Streamlit has been built to seamlessly integrate with matplotlib, plotly, seaborn, or even altair. It's also compatible with OpenCV, Vega-Lite, LaTeX, and many more. Streamlit is not a tool useful to anyone who would like to use Python Notebooks.

Streamlit can help the user create impressive dashboards that help to communicate data story across, allowing for exploration, analysis, and reporting. The fact that Streamlit is compatible with multiple graphing solutions means they can be joined on one dashboard, taking advantage of each of their individual strengths and weaknesses. 

Another major advantage of Streamlit is how it can be used on an already existing code base.

However, as with any solution, Streamlit comes with some disadvantages. For example, Streamlit does not allow for much customization, and changes that might be desirable and seemingly easy, such as having pop-ups in one's app or changing the visual of one's buttons, are simply not possible in native Streamlit environment. Streamlit also comes with a limited data upload which caps at 50Mb. Other methods such as getting url parameters require hacks that are not scalable for large operations (github issue 798). 

The support for animation and video is also fairly limited, as is the interactivity of graphs. 

Any time a change is made, the whole program reruns, and everything is recalculated, bringing potential performance issues. It does provide a caching solution, which is unfortunately not bullet-proof, and the user might find long loading times off-putting in case of the page loading over several minutes. The user is also not notified visually when the app is recalculating, which once again might be difficult for apps with long loading times.

Natively, Streamlit requires the user to run it with an external shell command. The user has to be sure that all of the dependencies are installed, and some technical knowledge is required to start the local server. 

\section{Dash}
\label{sec:dash}
Dash is another open-source Python package designed for building web applications. As the name suggests, Dash's main focus is on creating dashboards. Just as Streamlit, it can be installed via a simple pip command, and supports other languages used in bioinformatics such as R or Julia. The provided API is enough to work with for a Python user with no web development knowledge (HTML, CSS), once again though, knowledge of the web development languages can hugely benefit the user. Flask is used for Dash backend, and provides a Python wrapper for front-end part of the application, and Dash is said to be production ready. The high level API can create charts similar to what D3 is capable of. React.js is used for component rendering.

With just under 18K starts on GitHub in December 2022, it's just a tad less popular solution on the platform than Streamlit. However, Dash is a more mature product, which has been around for longer. More questions have been asked and answered on the internet. 

Dash outperforms Streamlit in both customizability and performance. It is less opinionated design wise. The documentation is well done, and kept up to date. The callback debugger is useful. HTTP Basic Authentication is provided. 

With the release of JupyterDash, integration with Jupyter is supported, even though it can be a bit unstable at times.

Dash also comes with a wide variety of example apps, which are available in the so called Dash App Gallery.

Since Dash comes from Plotly, it is mainly designed to work with Plotly graphing solution. Using other graph libraries is possible but it can be a bit of a hussle. 

One of the core features is the reactive Dash callback decorator. Plenty UI elements can be changed via the callbacks (dropdown menus, sliders, graphs), and the whole application has to be set accordingly to work with the linked input. Dash requires a bit more biolerplate code than R Shiny, however, it is easier to integrate one's CSS with Dash than R Shiny.

Dash is not suitable for building large scale web applications, and web applications with a lot of functionality other than analysis should not be expected from it. Proprietary components have to be written in React.js. 

PROBABLY ADD SECTIONS DIVIDING GRAPHING SOLUTIONS AND FRONTEND

\section{PyScript}
\label{sec:pyscript}
PyScript is a framework that promises connecting Python code to html, letting applications run in the browser without any JavaScript knowledge. JavaScript is not a programming language of choice for many scientists [SOURCE]. It requires little to no initial setup. The creation of PyScript was enabled by Pyodide, which is a CPython way to WebAssembly. 

PyScript is added to one's application by adding a link to it's source at the head of the HTML file. This solution requires a working internet connection, however, the files can be downloaded and linked locally, making it possible to run offline. PyScript comes with a .js file and a .css file. 

It is preferred using the Python code as a source, rather than inserting the code directly into the HTML PyScript tag to prevent potential formatting issues. 

Some Python libraries are available and need to be specified under a py-env tag or install via micropip. 

It is possible to interact with several HTML elements such as document, window, or console. Alternatively, it is possible to leverage Pyodide to create proxies between Python and JavaScript callbacks, or use prepared UI components such as buttons and text boxes. 

One main difference between PyScript and other Python solutions such as Dash \ref{sec:dash} or Streamlit \ref{sec:streamlit} is that while the latter solutions require a server to run, PyScript operates on the client side. Unlike Dash and Streamlit, basic HTML knowledge is necessary. 

It was announced in 2022, and as of 2023, it is in alpha stage of development. With that said, core functionality is still under development and may change in the nearby future. Additionaly, it lacks a lot of functionality one would need from such a solution, such as Plotly \ref{sec:plotly} not being supported. However, alternatives such as Bokeh are available. Even so, the graphs are not interactive. 

Pyscript makes it more difficult to debug one's application. 

PyScript was not chosen as a solution for this thesis as its loading times are incredibly slow [TIME IT, maybe Hello World?].

\section{Altair}
\label{sec:networkx}
Altair is relatively constrained as a graphing solution. It was build on Vega-lite, which calls itself a visualization grammar, and is a declarative language for interactive visualizations. While Altair in its core uses JSON to define properties, the user of Altair Python library does not need to do such thing: Altair does the converting for the user based on the inputs. It uses Pandas, therefore data can be manipulated in a manner similar to Pandas. Apart from Pandas DataFrame, the user can choose to input data in other formats such as Data and related objects, json file, csv file, url pointing to either of previously mentioned files. Altair is also of declarative nature meaning that Altair chooses a lot of "how to do" for the user and the user can focus on the "what to do", with a high-level approach. As other Python libraries, it can be easily install via a pip command. 

Altair wishes to keep the user focused on the data rather than formatting. In general, it can create simple graphs in less code than let's say Matplotlib, and much of the visual side of plots are taken care of by the Altair package. 

One of the biggest Altair advantages is that it comes with interactive plots out of the box, and the user can immediately take advantage of desirable functions such as zooming in and out, or highlighting parts of the plot. It's also extremely easy to connect multiple plots and have the selection apply to all of the graphs. 

Altair takes advantage of marks, which provide basic specification of visual representation of data, such as bar, image, circle, rectangle, and so on as provided by Chart.mark* methods. Once the data is input and the mark is chosen, the user can call the encoding. Encoding takes care of the placing of the chosen representations, setting the axes, choosing the colors to show individuality of the data points, the opacity and else. Encoding expects simple answers about the variable type. This setup promotes code reusability, in which the core code can be left the same while tweaking the plots.

By chaining more commands like interactive, tooltip or selection, the user can make Altair perform a variety of actions without setting up much of the code. 

From graphical point of view, one can write functions in Altair that are re-usable, for example a function for adding text with specific parameters can be defined once and used multiple times. This ability is connected to using Altair objects as return types and such use is recommended. 

One of the bigger disadvantages of Altair is the size constraint, and Altair documentation itself recommends to use only data with 5000 rows or less in order not to run into issues. In practice, this results into raising the MaxRowsError, not allowing the user to go over 5000 rows. This behavior can be disables, but as mentioned before, that is not recommended. Altair also does not support 3D visualizations, although a dimension can sometimes be added to a 2D graph with clever use of color. The support for statistical plots is limited, and there are better solutions to use when trying to plot e.g. linear regression. Compared to other plotting libraries, Altair is slow. 

\section{Networkx}
\label{sec:networkx}
Networkx was decided to be unfit for the task as while representing dendrograms in a form of a graph is possible, it is not the best solution. --maybe its not possible?

\section{Matplotlib}
\label{sec:matplotlib}
Matplotlib is a famous Python package based on MATLAB. It offers plenty of functionality. As it's based on MATLAB, the interface will seem familiar to those skilled in MATLAB, and it is both object oriented and state-based, which can lead to confusion at times.

Matplotlib has been around for quite some time, and has amassed over 16.5K starts and over 650K users on GitHub as of December 2022. Having a huge user base is an advantage, as there are usually more resources available. The documentation provides plenty of real life examples, and many more can be found scattered across various user-made applications. 

The low-level interface can be considered both an advantage and a disadvantage, for there is a learning curve. However, it also makes plotting even the most wild and complicated plots possible with a bit of work. Working with large and complex datasets can be challenging regardless of the chosen library. 

Matplotlib integrates flawlessly with Numpy, sklearn, or pandas. 

Creating 3D visualizations is possible in Matplotlib. Matplotlib comes with an animation module, bringing life to the user's graphs. The data representations can be either static, interactive, or dynamic. In general, there are better options for representing time series than Matplotlib.


\section{Bokeh}
\label{sec:bokeh}
Bokeh is also on a list of available open-source Python libraries that make data analysis easier. It cooperates with more web focused mediators such as Streamlit or PyScript. The API for creating plots and visualizations is designed to be simple and intuitive, and allows to be displayed in web browsers with use of JavaScript. The customizability is high, many details about the plots can be changed, including visual details such as color and line styles. The integration with Jupyter Notebook is supported, and Bokeh also gladly cooperates with Flask or Django. 

Although the API is quite simple, the underlying JavaScript can be overpowering for developers and data scientists who lack experience with web development. 

Apart from traditionally expected types of visualization such as line plots, scatter plots, or bar charts, it also comes with built-in tools that allow the user to interact with the plot. However, as Bokeh is a high-level tool, users might struggle to find the amount of customization they desire. Bokeh also does not go well with 3D visualizations. 

Unlike Altair, Bokeh's strenght comes from the ability to handle large datasets. It also allows the user to link multiple plots together and other desirable options expected to be necessary in a data exploration tool. 

\section{Plotly}
\label{sec:plotly}
Plotly is also an open-source Python package. Plotly is built on plotly.js, which is a Plotly JavaScript library, and also uses tools such as D3.js, HTML, and CSS. As such, it is appropriate to use with web in mind. Plotly also supports Jupyter Notebook integration. Plotly is also a high level declarative tool, meaning that it takes care of large portions of the visualization if the relationships between the data are specified clearly. While declarative tools save user time and code lines by making a lot of decisions for the user, it comes at an expense of less control over the plot and the details overall. 

Plotly can be used for interactive graphing, it supports 3D charts, and many other expected types of plots (scatter, violin, box, and others). Plotly offers tools for interacting with the plots, such as the hover feature, which can be used to identify outliers. However, the sheer amount of tools Plotly comes with sharpened learning curve and decision paralysis. 

Multipanel layouts are available, and while linking the panels together might not be as straightforward as in Altair, it is not overly difficult. 







